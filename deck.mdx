
import { Appear, Notes } from 'mdx-deck';
import { Invert, Split, FullScreenCode, Horizontal } from 'mdx-deck/layouts'
import {VerticalSplit, HorizontalSplit} from './CustomLayouts'
export { code as theme } from 'mdx-deck/themes'

# Refactors for Good JS

Built with mdx-deck:  https://github.com/jxnblk/mdx-deck/blob/master/docs/components.md

---

export default VerticalSplit;

# Decomposing Conditionals

<Appear>
  <div>

### Before

```jsx
if (date.before(SUMMER_START) || date.after(SUMMER_END)) {
  charge = quantity * winterRate + winterServiceCharge;
}
else {
  charge = quantity * summerRate;
}
```

  </div>
  <div>

### After

```jsx
if (isSummer(date)) {
  charge = summerCharge(quantity);
}
else {
  charge = winterCharge(quantity);
}
```

  </div>
</Appear>

<Notes>We can only keep so many things in mind at once</Notes>

---

export default HorizontalSplit;

## Replace Nested Conditional with Guard Clauses

<Appear>
  <div style={{marginRight: '6px'}}>

### Before

```jsx
function getPayAmount() {
  let result;
  if (isDead){
    result = deadAmount();
  }
  else {
    if (isSeparated){
      result = separatedAmount();
    }
    else {
      if (isRetired){
        result = retiredAmount();
      }
      else{
        result = normalPayAmount();
      }
    }
  }
  return result;
}
```

  </div>
  <div>

### After

```jsx
function getPayAmount() {
  if (isDead){
    return deadAmount();
  }
  if (isSeparated){
    return separatedAmount();
  }
  if (isRetired){
    return retiredAmount();
  }
  return normalPayAmount();
}
```


  </div>
</Appear>

<Notes>Nested conditionals can quickly get complicated and hard to read</Notes>

---

export default VerticalSplit;

# Parameterize Method

<Appear>
  <div>

### Before

```jsx
const raiseTenPercent = () => {};
const raiseFivePercent = () => {};
```

  </div>
  <div>

### After

```jsx
const raisePercent = (percent) => {};
```

  </div>
</Appear>

<Notes>When all but one or two parts of functions are duplicate</Notes>

---

export default HorizontalSplit;

# Replace Parameter with Explicit Methods

<Appear>
  <div style={{marginRight: '20px'}}>

### Before

```jsx
function setValue(name, value) {
  if (name.equals("height")) {
    height = value;
    return;
  }
  if (name.equals("width")) {
    width = value;
    return;
  }
}
```

  </div>
  <div>

### After

```jsx
function setHeight(arg) {
  height = arg;
}
function setWidth(arg) {
  width = arg;
}
```

  </div>
</Appear>

<Notes>When one function is doing too many things</Notes>

---

export default HorizontalSplit;

## React Components are Functions

<Appear>
  <div style={{marginRight: '20px'}}>

### Before

```jsx
function Dimension(props) {
  returm (
    <div>
      {if(props.height) {
        <h1>This is the height stuff</h1>
      }}
      {if(props.width) {
        <h1>This is the width stuff</h1>
      }}
    </div>
  );
}
```

  </div>
  <div>

### After

```jsx
function Parent(props) {
  return (
    <div>
      {props.showHeight && <Height />}
      {props.showWidth && <Width />}
    </div>
  );
}
```

  </div>
</Appear>

---

export default VerticalSplit;

# Replace Error Code with Exception

<Appear>
  <div>

### Before

```jsx
function withdraw(amount) {
  if (amount > _balance) {
    return -1;
  }
  else {
    balance -= amount;
    return 0;
  }
}
```

  </div>
  <div>

### After

```jsx
withdraw(amount) {
  if (amount > _balance) {
    throw new Error();
  }
  balance -= amount;
}
```

  </div>
</Appear>

<Notes>"throwing erros is one of the most under utilized featurs of javascript" - Arty Buldauskas</Notes>

---

export default VerticalSplit;

# Replace Exception with Test

<Appear>
  <div>

### Before

```jsx
function getValueForPeriod(periodNumber) {
  try {
    return values[periodNumber];
  } catch (ArrayIndexOutOfBoundsException e) {
    return 0;
  }
}
```

  </div>
  <div>

### After

```jsx
function getValueForPeriod(periodNumber) {
  if (periodNumber >= values.length) {
    return 0;
  }
  return values[periodNumber];
}
```

  </div>
</Appear>

<Notes>With good tests you can ensure error states will never be reached</Notes>

---

export default Invert;

# Thanks for coming!

* Decomposing Conditionals
* Replace Nested Conditional with Guard Clauses
* Parameterize Method
* Replace Parameter with Explicit Methods
* Replace Error Code with Exception
* Replace Exception with Test